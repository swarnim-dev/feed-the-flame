<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Last Flame</title>
    <style>
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            user-select: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
            cursor: crosshair;
            width: 100vw;
            height: 100vh;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 14px;
            text-shadow: 0 0 10px #ff6600;
        }
        
        #healthBar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff6600;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600, #ffff00);
            width: 100%;
            transition: width 0.3s ease;
        }
        
        #score {
            margin-bottom: 5px;
        }
        
        #message {
            font-size: 12px;
            color: #ffaa00;
            max-width: 300px;
            line-height: 1.4;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #888;
            z-index: 100;
        }
        
        #hintButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 100, 0, 0.8);
            color: #fff;
            border: 2px solid #ff6600;
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        #hintButton:hover {
            background: rgba(255, 100, 0, 1);
            box-shadow: 0 0 10px rgba(255, 100, 0, 0.5);
        }
        
        #hintButton:disabled {
            background: rgba(100, 100, 100, 0.5);
            border-color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        #highScoreBox {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            border: 2px solid #ffd700;
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 5px;
            font-family: inherit;
            z-index: 100;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #ff6600;
            display: none;
        }
        
        #gameOver h2 {
            color: #ff6600;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        #gameOver button {
            background: #ff6600;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 10px;
        }
        
        #gameOver button:hover {
            background: #ff8800;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="hud">
            <div id="healthBar">
                <div id="healthFill"></div>
            </div>
            <div id="score">Score: 0</div>
            <div id="message">Use WASD or Arrow Keys to move, Space to ignite nearby torches</div>
        </div>
        
        <div id="instructions">
            Controls: WASD/Arrow Keys = Move | Space = Ignite | R = Restart
        </div>
        
        <button id="hintButton" onclick="useHint()">Get Hint</button>
        
        <div id="highScoreBox">
            High Score: <span id="highScoreValue">0</span>
        </div>
        
        <div id="gameOver">
            <h2 id="gameOverTitle">Game Over</h2>
            <p id="gameOverMessage">Your flame has been extinguished...</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">Try Again</button>
        </div>
    </div>

    <script>
        const GAME_CONFIG = {
            FLAME_SIZE: 20,
            FLAME_SPEED: 5,
            HEALTH_DRAIN_RATE: 0.1,
            IGNITE_COST: 15,
            IGNITE_COOLDOWN: 1000,
            IGNITE_RANGE: 60,
            DARKNESS_DRAIN_RATE: 0.1,
            LIGHT_RADIUS: 80,
            NUM_TORCHES: 8,
            TORCH_SIZE: 24,
            CANVAS_WIDTH: window.innerWidth,
            CANVAS_HEIGHT: window.innerHeight
        };

        let gameState = {
            canvas: null,
            ctx: null,
            flame: null,
            torches: [],
            score: 0,
            highScore: 0,
            gameRunning: true,
            lastIgniteTime: 0,
            narration: [],
            currentMessage: '',
            messageTimer: 0,
            particles: [],
            backgroundParticles: [],
            audioContext: null,
            backgroundMusic: null,
            sparkSound: null,
            deathSound: null,
            hintActive: false,
            hintTarget: null,
            hintCooldown: 0,
            hintCooldownTime: 10000
        };

        class Particle {
            constructor(x, y, vx, vy, life, color, size) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.color = color;
                this.size = size;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.vx *= 0.98;
                this.vy *= 0.98;
            }

            draw(ctx) {
                const alpha = this.life / this.maxLife;
                ctx.fillStyle = `${this.color}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        class Flame {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.health = 100;
                this.vx = 0;
                this.vy = 0;
                this.radius = GAME_CONFIG.FLAME_SIZE;
                this.flickerOffset = Math.random() * Math.PI * 2;
                this.flickerSpeed = 0.1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                this.x = Math.max(this.radius, Math.min(GAME_CONFIG.CANVAS_WIDTH - this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(GAME_CONFIG.CANVAS_HEIGHT - this.radius, this.y));
                
                this.health -= GAME_CONFIG.HEALTH_DRAIN_RATE / 60;
                
                let nearLight = false;
                for (let torch of gameState.torches) {
                    if (torch.lit) {
                        const distance = Math.sqrt((this.x - torch.x) ** 2 + (this.y - torch.y) ** 2);
                        if (distance < GAME_CONFIG.LIGHT_RADIUS) {
                            nearLight = true;
                            break;
                        }
                    }
                }
                
                if (!nearLight) {
                    this.health -= GAME_CONFIG.DARKNESS_DRAIN_RATE / 60;
                }
                
                this.health = Math.max(0, Math.min(100, this.health));
            }

            ignite() {
                const now = Date.now();
                if (now - gameState.lastIgniteTime < GAME_CONFIG.IGNITE_COOLDOWN) {
                    return false;
                }
                
                if (this.health < GAME_CONFIG.IGNITE_COST) {
                    return false;
                }
                
                let ignited = false;
                for (let torch of gameState.torches) {
                    if (!torch.lit) {
                        const distance = Math.sqrt((this.x - torch.x) ** 2 + (this.y - torch.y) ** 2);
                        if (distance < GAME_CONFIG.IGNITE_RANGE) {
                            torch.lit = true;
                            gameState.score += 10;
                            ignited = true;
                        }
                    }
                }
                
                if (ignited) {
                    this.health -= GAME_CONFIG.IGNITE_COST;
                    gameState.lastIgniteTime = now;
                    showMessage("Torch ignited! +10 points");
                    playSound('spark');
                    
                    for (let i = 0; i < 15; i++) {
                        const angle = (Math.PI * 2 * i) / 15;
                        const speed = 3 + Math.random() * 2;
                        const vx = Math.cos(angle) * speed;
                        const vy = Math.sin(angle) * speed;
                        
                        gameState.particles.push(new Particle(
                            this.x, this.y, vx, vy,
                            40, '#ffff00', 3
                        ));
                    }
                }
                
                return ignited;
            }

            draw(ctx) {
                const time = Date.now() * 0.01;
                const flicker = Math.sin(time + this.flickerOffset) * 0.1 + 1;
                const currentRadius = this.radius * flicker;
                
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentRadius * 3);
                gradient.addColorStop(0, `rgba(255, 100, 0, ${this.health / 100})`);
                gradient.addColorStop(0.5, `rgba(255, 200, 0, ${this.health / 200})`);
                gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 3, 0, Math.PI * 2);
                ctx.fill();
                
                const flameIntensity = this.health / 100;
                ctx.fillStyle = `rgba(255, ${100 + this.health * 0.5}, 0, ${flameIntensity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                const coreFlicker = Math.sin(time * 1.5 + this.flickerOffset) * 0.2 + 1;
                ctx.fillStyle = `rgba(255, 255, 200, 0.9)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 0.6 * coreFlicker, 0, Math.PI * 2);
                ctx.fill();
                
                if (Math.random() < 0.3) {
                    const particleX = this.x + (Math.random() - 0.5) * currentRadius;
                    const particleY = this.y + (Math.random() - 0.5) * currentRadius;
                    const particleVx = (Math.random() - 0.5) * 2;
                    const particleVy = -Math.random() * 3 - 1;
                    
                    gameState.particles.push(new Particle(
                        particleX, particleY, particleVx, particleVy,
                        30, '#ff6600', 2
                    ));
                }
            }
        }

        class Torch {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.lit = false;
                this.radius = GAME_CONFIG.TORCH_SIZE / 2;
                this.visible = false;
                this.fireImage = null;
                this.loadFireImage();
            }
            
            loadFireImage() {
                this.fireImage = new Image();
                this.fireImage.onload = () => {
                    console.log('Torch lit image loaded');
                };
                this.fireImage.onerror = () => {
                    console.log('Torch lit image not found, using default flame');
                    this.fireImage = null;
                };
                this.fireImage.src = './assets/torch_lit.png';
            }

            draw(ctx) {
                if (this.lit) {
                    const time = Date.now() * 0.003;
                    const pulse = Math.sin(time + this.x * 0.01) * 0.15 + 0.85;
                    const flicker = Math.sin(time * 2.5 + this.y * 0.01) * 0.1 + 1;
                    
                    // Bright but smaller glow system
                    const outerGlow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, GAME_CONFIG.LIGHT_RADIUS);
                    outerGlow.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                    outerGlow.addColorStop(0.15, 'rgba(255, 255, 200, 0.95)');
                    outerGlow.addColorStop(0.3, 'rgba(255, 200, 100, 0.9)');
                    outerGlow.addColorStop(0.5, 'rgba(255, 150, 50, 0.8)');
                    outerGlow.addColorStop(0.7, 'rgba(255, 100, 0, 0.6)');
                    outerGlow.addColorStop(0.9, 'rgba(255, 50, 0, 0.3)');
                    outerGlow.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    
                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, GAME_CONFIG.LIGHT_RADIUS * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright inner core (smaller)
                    const innerGlow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 50);
                    innerGlow.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                    innerGlow.addColorStop(0.2, 'rgba(255, 255, 200, 0.9)');
                    innerGlow.addColorStop(0.5, 'rgba(255, 200, 100, 0.7)');
                    innerGlow.addColorStop(0.8, 'rgba(255, 150, 50, 0.4)');
                    innerGlow.addColorStop(1, 'rgba(255, 200, 100, 0)');
                    
                    ctx.fillStyle = innerGlow;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 50 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright white core (smaller)
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 25 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Enhanced torch base with better shading
                    const baseGradient = ctx.createLinearGradient(this.x - 4, this.y, this.x + 4, this.y + 18);
                    baseGradient.addColorStop(0, '#8B4513');
                    baseGradient.addColorStop(0.3, '#A0522D');
                    baseGradient.addColorStop(0.7, '#8B4513');
                    baseGradient.addColorStop(1, '#654321');
                    
                    ctx.fillStyle = baseGradient;
                    ctx.fillRect(this.x - 5, this.y, 10, 20);
                    
                    // Enhanced base outline with glow
                    ctx.strokeStyle = '#D2691E';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - 5, this.y, 10, 20);
                    
                    // Subtle inner highlight
                    ctx.strokeStyle = '#F4A460';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - 4, this.y + 1, 8, 18);
                    
                    if (this.fireImage && this.fireImage.complete) {
                        // Much brighter image rendering with intense glow
                        ctx.save();
                        
                        // Bright but smaller glow for image
                        const imageGlow1 = ctx.createRadialGradient(this.x, this.y - 8, 0, this.x, this.y - 8, 20);
                        imageGlow1.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                        imageGlow1.addColorStop(0.3, 'rgba(255, 255, 200, 0.9)');
                        imageGlow1.addColorStop(0.7, 'rgba(255, 200, 100, 0.6)');
                        imageGlow1.addColorStop(1, 'rgba(255, 200, 100, 0)');
                        
                        ctx.fillStyle = imageGlow1;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 8, 20 * flicker, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bright core (smaller)
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 8, 10 * flicker, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Draw the image with maximum brightness
                        ctx.globalAlpha = 1.0;
                        ctx.drawImage(this.fireImage, this.x - 16, this.y - 24, 32, 32);
                        
                        // Bright white overlay for extra visibility
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(this.x - 16, this.y - 24, 32, 32);
                        
                        // Additional bright highlight
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(this.x - 16, this.y - 24, 32, 32);
                        
                        ctx.restore();
                    } else {
                        // Enhanced default flame with better animation
                        const flameTime = Date.now() * 0.008;
                        const flameFlicker = Math.sin(flameTime + this.x * 0.01) * 0.25 + 1;
                        const flamePulse = Math.sin(flameTime * 1.5 + this.y * 0.01) * 0.15 + 0.85;
                        
                        // Much brighter outer flame
                        const flameGradient = ctx.createRadialGradient(this.x, this.y - 8, 0, this.x, this.y - 8, 20);
                        flameGradient.addColorStop(0, '#ffaa00');
                        flameGradient.addColorStop(0.3, '#ff8800');
                        flameGradient.addColorStop(0.7, '#ff6600');
                        flameGradient.addColorStop(1, '#ff4400');
                        
                        ctx.fillStyle = flameGradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 8, 20 * flameFlicker, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Bright middle flame layer
                        const middleGradient = ctx.createRadialGradient(this.x, this.y - 8, 0, this.x, this.y - 8, 14);
                        middleGradient.addColorStop(0, '#ffff00');
                        middleGradient.addColorStop(0.4, '#ffaa00');
                        middleGradient.addColorStop(0.8, '#ff8800');
                        middleGradient.addColorStop(1, '#ff6600');
                        
                        ctx.fillStyle = middleGradient;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 8, 14 * flameFlicker, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Super bright white core
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 8, 8 * flameFlicker, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Additional bright yellow core
                        ctx.fillStyle = '#ffff00';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y - 8, 5 * flameFlicker, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Enhanced flame particles with better animation
                        ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                        for (let i = 0; i < 8; i++) {
                            const angle = (flameTime * 2 + i * 0.8) % (Math.PI * 2);
                            const radius = 8 + Math.sin(flameTime * 3 + i) * 4;
                            const offsetX = Math.cos(angle) * radius;
                            const offsetY = Math.sin(angle) * radius - 8;
                            const size = 2 + Math.sin(flameTime * 4 + i) * 1;
                            
                            ctx.beginPath();
                            ctx.arc(this.x + offsetX, this.y + offsetY, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                } else if (this.visible) {
                    // Much more visible unlit torch with better contrast
                    const unlitGradient = ctx.createLinearGradient(this.x - 6, this.y, this.x + 6, this.y + 22);
                    unlitGradient.addColorStop(0, '#6A6A6A');
                    unlitGradient.addColorStop(0.2, '#7A7A7A');
                    unlitGradient.addColorStop(0.5, '#6A6A6A');
                    unlitGradient.addColorStop(0.8, '#5A5A5A');
                    unlitGradient.addColorStop(1, '#4A4A4A');
                    
                    ctx.fillStyle = unlitGradient;
                    ctx.fillRect(this.x - 6, this.y, 12, 22);
                    
                    // Bright outline for better visibility
                    ctx.strokeStyle = '#888';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - 6, this.y, 12, 22);
                    
                    // Additional bright inner outline
                    ctx.strokeStyle = '#AAA';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 5, this.y + 1, 10, 20);
                    
                    // Subtle glow effect for unlit torch
                    const unlitGlow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, 15);
                    unlitGlow.addColorStop(0, 'rgba(150, 150, 150, 0.3)');
                    unlitGlow.addColorStop(0.5, 'rgba(100, 100, 100, 0.2)');
                    unlitGlow.addColorStop(1, 'rgba(100, 100, 100, 0)');
                    
                    ctx.fillStyle = unlitGlow;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add a small dark flame outline to show it's unlit
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x - 2, this.y - 6, 4, 8);
                    
                    // Dark flame outline
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x - 2, this.y - 6, 4, 8);
                }
            }
        }

        function resizeCanvas() {
            GAME_CONFIG.CANVAS_WIDTH = window.innerWidth;
            GAME_CONFIG.CANVAS_HEIGHT = window.innerHeight;
            
            if (gameState.canvas) {
                gameState.canvas.width = GAME_CONFIG.CANVAS_WIDTH;
                gameState.canvas.height = GAME_CONFIG.CANVAS_HEIGHT;
            }
        }

        function initGame() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            resizeCanvas();
            
            gameState.flame = new Flame(GAME_CONFIG.CANVAS_WIDTH / 2, GAME_CONFIG.CANVAS_HEIGHT / 2);
            
            gameState.torches = [];
                const margin = 100;
            const minDistance = 200;
            
            for (let i = 0; i < GAME_CONFIG.NUM_TORCHES; i++) {
                let attempts = 0;
                let x, y;
                let validPosition = false;
                
                while (!validPosition && attempts < 50) {
                    x = margin + Math.random() * (GAME_CONFIG.CANVAS_WIDTH - 2 * margin);
                    y = margin + Math.random() * (GAME_CONFIG.CANVAS_HEIGHT - 2 * margin);
                    
                    validPosition = true;
                    for (let existingTorch of gameState.torches) {
                        const distance = Math.sqrt((x - existingTorch.x) ** 2 + (y - existingTorch.y) ** 2);
                        if (distance < minDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }
                
                gameState.torches.push(new Torch(x, y));
            }
            
            loadAudioFiles();
            loadNarration();
            loadHighScore();
            gameState.canvas.addEventListener('click', (e) => {
                if (!gameState.gameRunning) return;
                
                const rect = gameState.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (GAME_CONFIG.CANVAS_WIDTH / rect.width);
                const y = (e.clientY - rect.top) * (GAME_CONFIG.CANVAS_HEIGHT / rect.height);
                
                const dx = x - gameState.flame.x;
                const dy = y - gameState.flame.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    gameState.flame.vx = (dx / distance) * GAME_CONFIG.FLAME_SPEED;
                    gameState.flame.vy = (dy / distance) * GAME_CONFIG.FLAME_SPEED;
                }
            });
            
            gameLoop();
            setTimeout(() => {
                playBackgroundMusic();
            }, 1000);
        }

        function loadAudioFiles() {
            gameState.backgroundMusic = new Audio('./assets/ember_loop.mp3');
            gameState.backgroundMusic.loop = true;
            gameState.backgroundMusic.volume = 0.3;
            gameState.sparkSound = new Audio('./assets/spark.wav');
            gameState.deathSound = new Audio('./assets/death.wav');
            initAudio();
        }

        async function loadNarration() {
            try {
                const response = await fetch('./assets/narration.json');
                gameState.narration = await response.json();
                showRandomMessage();
            } catch (error) {
                console.log('Using default narration');
                gameState.narration = [
                    "The darkness whispers of forgotten flames...",
                    "Each torch you light costs a piece of yourself.",
                    "In the void, even light must be earned.",
                    "Your flame flickers with determination.",
                    "The shadows grow longer with each passing moment.",
                    "Hope burns brightest in the darkest places.",
                    "Every spark is a small victory against the night.",
                    "The darkness remembers what light forgets.",
                    "Your courage illuminates the path forward.",
                    "In the end, we are all just temporary flames.",
                    "The last light before eternal darkness.",
                    "Burning bright, burning brief, burning true."
                ];
                showRandomMessage();
            }
        }

        function showRandomMessage() {
            if (gameState.narration.length > 0) {
                const message = gameState.narration[Math.floor(Math.random() * gameState.narration.length)];
                // Replace placeholders
                const processedMessage = message
                    .replace('{health}', Math.round(gameState.flame.health))
                    .replace('{score}', gameState.score);
                showMessage(processedMessage);
            }
        }

        function showMessage(text) {
            gameState.currentMessage = text;
            gameState.messageTimer = 300; // 5 seconds at 60 FPS
        }

        function gameLoop() {
            if (!gameState.gameRunning) return;
            
            update();
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        function update() {
            if (!gameState.gameRunning) return;
            
            gameState.flame.update();
            
            for (let torch of gameState.torches) {
                const distance = Math.sqrt(
                    (gameState.flame.x - torch.x) ** 2 + 
                    (gameState.flame.y - torch.y) ** 2
                );
                torch.visible = distance < 120;
            }
            
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.update();
                if (particle.isDead()) {
                    gameState.particles.splice(i, 1);
                }
            }
            for (let i = gameState.backgroundParticles.length - 1; i >= 0; i--) {
                const particle = gameState.backgroundParticles[i];
                particle.update();
                if (particle.isDead()) {
                    gameState.backgroundParticles.splice(i, 1);
                }
            }
            if (Math.random() < 0.02) {
                const x = Math.random() * GAME_CONFIG.CANVAS_WIDTH;
                const y = Math.random() * GAME_CONFIG.CANVAS_HEIGHT;
                const vx = (Math.random() - 0.5) * 0.5;
                const vy = (Math.random() - 0.5) * 0.5;
                
                gameState.backgroundParticles.push(new Particle(
                    x, y, vx, vy, 300, '#333333', 1
                ));
            }
            
            if (gameState.messageTimer > 0) {
                gameState.messageTimer--;
            }
            updateHintCooldown();
            updateHintButton();
            if (gameState.hintActive && gameState.hintTarget && gameState.hintTarget.lit) {
                gameState.hintActive = false;
                gameState.hintTarget = null;
                showMessage("Torch found! Hint deactivated.");
            }
            updateHUD();
            if (gameState.flame.health <= 0) {
                gameOver("Your flame has been extinguished...");
            }
            
            // Check win condition (all torches lit)
            const allTorchesLit = gameState.torches.every(torch => torch.lit);
            if (allTorchesLit) {
                gameOver("You have illuminated the darkness! Victory!");
            }
        }

        function draw() {
            const ctx = gameState.ctx;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            // Draw background (placeholder for image)
            drawBackground(ctx);
            
            // Draw background particles
            for (let particle of gameState.backgroundParticles) {
                particle.draw(ctx);
            }
            
            // Draw torches
            for (let torch of gameState.torches) {
                torch.draw(ctx);
            }
            
            // Draw flame
            gameState.flame.draw(ctx);
            
            // Draw particles
            for (let particle of gameState.particles) {
                particle.draw(ctx);
            }
            
            // Draw darkness overlay
            drawDarknessOverlay(ctx);
            
            // Draw flame again on top of darkness to ensure visibility
            gameState.flame.draw(ctx);
            
            // Draw particles again on top of darkness
            for (let particle of gameState.particles) {
                particle.draw(ctx);
            }
            
            // Draw hint arrow
            drawHintArrow(ctx);
        }

        function drawBackground(ctx) {
            // Placeholder background - replace with background.jpg
            const gradient = ctx.createLinearGradient(0, 0, 0, GAME_CONFIG.CANVAS_HEIGHT);
            gradient.addColorStop(0, '#1a0a0a');
            gradient.addColorStop(0.5, '#0a0a1a');
            gradient.addColorStop(1, '#000');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            // Add some atmospheric elements
            ctx.fillStyle = 'rgba(100, 50, 0, 0.1)';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * GAME_CONFIG.CANVAS_WIDTH;
                const y = Math.random() * GAME_CONFIG.CANVAS_HEIGHT;
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawDarknessOverlay(ctx) {
            // Create darkness mask
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            
            // Dark overlay - reduced opacity so flame is more visible
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            // Punch holes for light sources
            ctx.globalCompositeOperation = 'destination-out';
            
            // Flame light - larger radius for better visibility
            const flameGradient = ctx.createRadialGradient(
                gameState.flame.x, gameState.flame.y, 0,
                gameState.flame.x, gameState.flame.y, gameState.flame.radius * 4
            );
            flameGradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
            flameGradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.8)');
            flameGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = flameGradient;
            ctx.beginPath();
            ctx.arc(gameState.flame.x, gameState.flame.y, gameState.flame.radius * 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Lit torch lights
            for (let torch of gameState.torches) {
                if (torch.lit) {
                    const torchGradient = ctx.createRadialGradient(
                        torch.x, torch.y, 0,
                        torch.x, torch.y, GAME_CONFIG.LIGHT_RADIUS
                    );
                    torchGradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                    torchGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    ctx.fillStyle = torchGradient;
                    ctx.beginPath();
                    ctx.arc(torch.x, torch.y, GAME_CONFIG.LIGHT_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }

        function updateHUD() {
            // Update health bar
            const healthPercent = (gameState.flame.health / 100) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            
            // Update score
            document.getElementById('score').textContent = `Score: ${gameState.score}`;
            
            // Update high score in the highlighted box
            document.getElementById('highScoreValue').textContent = gameState.highScore;
            
            // Update message
            const messageEl = document.getElementById('message');
            if (gameState.messageTimer > 0) {
                messageEl.textContent = gameState.currentMessage;
                messageEl.style.opacity = '1';
            } else {
                messageEl.style.opacity = '0.5';
                messageEl.textContent = 'Use WASD or Arrow Keys to move, Space to ignite nearby torches';
            }
        }

        const keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState.gameRunning) {
                    gameState.flame.ignite();
                }
            }
            
            if (e.code === 'KeyR') {
                restartGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        
        function updateMovement() {
            if (!gameState.gameRunning) return;
            
            const flame = gameState.flame;
            flame.vx = 0;
            flame.vy = 0;
            
            if (keys['KeyW'] || keys['ArrowUp']) flame.vy = -GAME_CONFIG.FLAME_SPEED;
            if (keys['KeyS'] || keys['ArrowDown']) flame.vy = GAME_CONFIG.FLAME_SPEED;
            if (keys['KeyA'] || keys['ArrowLeft']) flame.vx = -GAME_CONFIG.FLAME_SPEED;
            if (keys['KeyD'] || keys['ArrowRight']) flame.vx = GAME_CONFIG.FLAME_SPEED;
        }

        function gameOver(message) {
            gameState.gameRunning = false;
            saveHighScore();
            
            const isNewHighScore = gameState.score > 0 && gameState.score === gameState.highScore;
            
            document.getElementById('gameOverTitle').textContent = isNewHighScore ? 'New High Score!' : 'Game Over';
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'block';
            playSound('death');
        }

        function restartGame() {
            gameState.gameRunning = true;
            gameState.score = 0;
            gameState.lastIgniteTime = 0;
            gameState.currentMessage = '';
            gameState.messageTimer = 0;
            
            // Clear all particles
            gameState.particles = [];
            gameState.backgroundParticles = [];
            
            // Reset hint system
            gameState.hintActive = false;
            gameState.hintTarget = null;
            gameState.hintCooldown = 0;
            
            // Reset flame
            gameState.flame = new Flame(GAME_CONFIG.CANVAS_WIDTH / 2, GAME_CONFIG.CANVAS_HEIGHT / 2);
            
            // Reset and randomize torches with proper spacing
            const margin = 100;
            const minDistance = 200;
            
            for (let i = 0; i < gameState.torches.length; i++) {
                let attempts = 0;
                let x, y;
                let validPosition = false;
                
                while (!validPosition && attempts < 50) {
                    x = margin + Math.random() * (GAME_CONFIG.CANVAS_WIDTH - 2 * margin);
                    y = margin + Math.random() * (GAME_CONFIG.CANVAS_HEIGHT - 2 * margin);
                    
                    // Check distance from other torches
                    validPosition = true;
                    for (let j = 0; j < i; j++) {
                        const distance = Math.sqrt((x - gameState.torches[j].x) ** 2 + (y - gameState.torches[j].y) ** 2);
                        if (distance < minDistance) {
                            validPosition = false;
                            break;
                        }
                    }
                    attempts++;
                }
                
                gameState.torches[i].lit = false;
                gameState.torches[i].x = x;
                gameState.torches[i].y = y;
            }
            
            document.getElementById('gameOver').style.display = 'none';
            showRandomMessage();
            
            // Restart background music
            playBackgroundMusic();
        }

        function useHint() {
            if (gameState.hintCooldown > 0 || !gameState.gameRunning) return;
            
            // Find the nearest unlit torch
            let nearestTorch = null;
            let nearestDistance = Infinity;
            
            for (let torch of gameState.torches) {
                if (!torch.lit) {
                    const distance = Math.sqrt(
                        (gameState.flame.x - torch.x) ** 2 + 
                        (gameState.flame.y - torch.y) ** 2
                    );
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestTorch = torch;
                    }
                }
            }
            
            if (nearestTorch) {
                gameState.hintActive = true;
                gameState.hintTarget = nearestTorch;
                gameState.hintCooldown = gameState.hintCooldownTime;
                showMessage("Hint: Follow the arrows to the nearest torch!");
            } else {
                showMessage("All torches are already lit!");
            }
        }
        
        function updateHintCooldown() {
            if (gameState.hintCooldown > 0) {
                gameState.hintCooldown -= 16; // Assuming 60 FPS
                if (gameState.hintCooldown <= 0) {
                    gameState.hintCooldown = 0;
                }
            }
        }
        
        function drawHintArrow(ctx) {
            if (!gameState.hintActive || !gameState.hintTarget) return;
            
            const target = gameState.hintTarget;
            const flame = gameState.flame;
            
            // Calculate direction to target
            const dx = target.x - flame.x;
            const dy = target.y - flame.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 50) {
                // Target is very close, hide arrow
                gameState.hintActive = false;
                gameState.hintTarget = null;
                return;
            }
            
            // Normalize direction
            const dirX = dx / distance;
            const dirY = dy / distance;
            
            // Position arrow at edge of screen in direction of target
            const arrowDistance = 80;
            const arrowX = flame.x + dirX * arrowDistance;
            const arrowY = flame.y + dirY * arrowDistance;
            
            // Keep arrow on screen
            const clampedX = Math.max(30, Math.min(GAME_CONFIG.CANVAS_WIDTH - 30, arrowX));
            const clampedY = Math.max(30, Math.min(GAME_CONFIG.CANVAS_HEIGHT - 30, arrowY));
            
            // Draw pulsing arrow
            const time = Date.now() * 0.005;
            const pulse = Math.sin(time) * 0.3 + 0.7;
            const alpha = pulse;
            
            ctx.save();
            ctx.globalAlpha = alpha;
            
            // Arrow glow
            const gradient = ctx.createRadialGradient(clampedX, clampedY, 0, clampedX, clampedY, 25);
            gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(clampedX, clampedY, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Arrow shape
            ctx.fillStyle = '#ffff00';
            ctx.strokeStyle = '#ff6600';
            ctx.lineWidth = 3;
            
            const arrowSize = 15;
            const angle = Math.atan2(dirY, dirX);
            
            ctx.translate(clampedX, clampedY);
            ctx.rotate(angle);
            
            ctx.beginPath();
            ctx.moveTo(arrowSize, 0);
            ctx.lineTo(-arrowSize, -arrowSize * 0.6);
            ctx.lineTo(-arrowSize * 0.3, 0);
            ctx.lineTo(-arrowSize, arrowSize * 0.6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
            
            // Draw distance text
            ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.round(distance)}px`, clampedX, clampedY + 35);
        }
        
        function updateHintButton() {
            const button = document.getElementById('hintButton');
            if (gameState.hintCooldown > 0) {
                const secondsLeft = Math.ceil(gameState.hintCooldown / 1000);
                button.textContent = `Hint (${secondsLeft}s)`;
                button.disabled = true;
            } else {
                button.textContent = 'Get Hint';
                button.disabled = false;
            }
        }

        function loadHighScore() {
            const savedHighScore = localStorage.getItem('lastFlameHighScore');
            if (savedHighScore) {
                gameState.highScore = parseInt(savedHighScore);
            }
        }

        function saveHighScore() {
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('lastFlameHighScore', gameState.highScore.toString());
                updateHUD(); // Update the display immediately
                
                // Add visual effect for new high score
                const highScoreBox = document.getElementById('highScoreBox');
                highScoreBox.style.background = 'rgba(255, 255, 0, 0.9)';
                highScoreBox.style.boxShadow = '0 0 20px rgba(255, 255, 0, 0.8)';
                setTimeout(() => {
                    highScoreBox.style.background = 'rgba(255, 215, 0, 0.9)';
                    highScoreBox.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                }, 2000);
            }
        }

        function initAudio() {
            try {
                gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Load background music
                if (gameState.backgroundMusic) {
                    gameState.backgroundMusic.loop = true;
                    gameState.backgroundMusic.volume = 0.3;
                }
            } catch (error) {
                console.log('Audio not supported');
            }
        }

        function playSound(soundName) {
            if (!gameState.audioContext) return;
            
            try {
                let audioFile = null;
                let volume = 0.5;
                
                switch (soundName) {
                    case 'spark':
                        audioFile = gameState.sparkSound;
                        volume = 0.7;
                        break;
                    case 'death':
                        audioFile = gameState.deathSound;
                        volume = 0.8;
                        break;
                }
                
                if (audioFile) {
                    const audio = audioFile.cloneNode();
                    audio.volume = volume;
                    audio.play().catch(e => console.log('Audio play failed:', e));
                }
            } catch (error) {
                console.log('Audio playback failed:', error);
            }
        }

        function playBackgroundMusic() {
            if (gameState.backgroundMusic) {
                gameState.backgroundMusic.play().catch(e => console.log('Background music failed:', e));
            }
        }

        function stopBackgroundMusic() {
            if (gameState.backgroundMusic) {
                gameState.backgroundMusic.pause();
                gameState.backgroundMusic.currentTime = 0;
            }
        }

        window.addEventListener('load', () => {
            initGame();
            
            // Update movement in game loop
            setInterval(updateMovement, 1000 / 60);
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvas();
            // Reposition torches randomly for new screen size with proper spacing
            if (gameState.torches.length > 0) {
                const margin = 100;
                const minDistance = 200;
                
                for (let i = 0; i < gameState.torches.length; i++) {
                    let attempts = 0;
                    let x, y;
                    let validPosition = false;
                    
                    while (!validPosition && attempts < 50) {
                        x = margin + Math.random() * (GAME_CONFIG.CANVAS_WIDTH - 2 * margin);
                        y = margin + Math.random() * (GAME_CONFIG.CANVAS_HEIGHT - 2 * margin);
                        
                        // Check distance from other torches
                        validPosition = true;
                        for (let j = 0; j < i; j++) {
                            const distance = Math.sqrt((x - gameState.torches[j].x) ** 2 + (y - gameState.torches[j].y) ** 2);
                            if (distance < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        attempts++;
                    }
                    
                    gameState.torches[i].x = x;
                    gameState.torches[i].y = y;
                }
            }
        });
    </script>
</body>
</html>
